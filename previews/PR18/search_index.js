var documenterSearchIndex = {"docs":
[{"location":"comparisons/bioconductor/#bioconductor","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"","category":"section"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"Bioconductor represents an ecosystem of related genomics tools written in the R programming language\nTools written in other languages, such as C and Python, are also included with R wrappers available \nLaunched over two decades ago, it now hosts over 2000 packages for bioinformatics and related fields\nPackages cover a broard range of methods for the analysis and manipulation of genomic data","category":"page"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"A few similar applications between BioJulia and Bioconductor:","category":"page"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"Application BioJulia packages Bioconductor packages\nData structures BioSymbols, KmerAnalysis, IntervalTrees Biobase\nSequence annotation GenomicFeatures, GenomicAnnotations, FormatSpecimens AnnotationHub\nInput/Output FASTX, XAM, BigWig, etc. BiocIO, Biostrings, ShortRead, etc.\nSequence alignment BioSequences, BioAlignments Biostrings\nExpression analysis SingleCellProjections DESeq2","category":"page"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"A few package/ecosystem equivalents between Julia and R:","category":"page"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"Application Julia R\nData manipulation/analysis DataFrames, CSV, Query, Tidier tibble, dplyr, tidyverse\nPlotting/visualization Gadfly, VegaLite, Makie, TidierPlots ggplot2, vegalite, plotly\nStatistical analysis Statistics, HypothesisTests, GLM stats\nMachine learning Flux, SciML, MLJ, Zygote mlr3, caret, tidymodels, Deriv\nNumerical mathematics LinearAlgebra, IterativeSolvers Matrix, pracma, deSolve\nWeb applications Genie, Franklin shiny","category":"page"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"A few notable differences between Julia and R:","category":"page"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"Julia R\nHigh-level, general-purpose compiled language High-level, interpreted language for statistical computing and data visualization\nDynamically typed with multiple dispatch and optional type annotations Dynamically typed without type annotations support\nBuilt-in parallelism via threads, coroutines (Tasks) Parallelism via external libraries (BLAS, parallel, etc.)\nLisp-like (homoiconic, macro-based) metaprogramming Partially homoiconic, non-standard evaluation metaprogramming\nSingle implementation available (JuliaLang) Multiple implementations available (pqR, Renjin, etc.)","category":"page"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"To transition from R to Julia:","category":"page"},{"location":"comparisons/bioconductor/","page":"Bioconductor (R)","title":"Bioconductor (R)","text":"See Noteworthy differences from R in the Julia manual for a more in-depth comparison\nUse RCall.jl to seamlessly integrate R code into your Julia project\nUse JuliaCall to seamlessly integrate Julia code into your R project\nCheck out the Tidier.jl ecosystem for packages similar to those commonly found in R's tidyverse","category":"page"},{"location":"comparisons/bioruby/#bioruby","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"","category":"section"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"BioRuby represents an ecosystem of related biology tools written in the Ruby programming language\nUnlike with BioJulia, BioRuby tools are installed together as classes/modules into a single bio gem\nLaunched in 2000 with two major releases covering the Ruby1/2/3 transitions\nPrimarily composed of wrapper classes/modules for common bioinformatics, molecular biology applications ","category":"page"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"A few similar applications between BioJulia and BioRuby:","category":"page"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"Application BioJulia packages BioRuby classes/modules\nSequence alignment BioSequences, BioAlignments Bio::Sequence, Bio::Alignment\nInput/Output FASTX, XAM, BigWig, etc. Bio::Fasta, Bio::Fastq, etc.","category":"page"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"A few package/ecosystem equivalents between Julia and Ruby:","category":"page"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"Application Julia Ruby\nData manipulation/analysis DataFrames, CSV, Query daru, CSV\nPlotting/visualization Plots, Makie, TidierPlots Chartkick, gruff\nStatistical analysis Statistics, HypothesisTests, GLM, Distributions Statsample, distribution\nMachine learning Flux, SciML Rumale, TensorStream\nNumerical mathematics LinearAlgebra NMatrix, minimization, integration\nNotebook/report generator IJulia, Pluto IRuby\nWeb applications Genie, Franklin Hanami, Jekyll","category":"page"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"A few notable differences between Julia and Ruby:","category":"page"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"Julia Ruby\nHigh-level, general-purpose compiled language High-level, general-purpose interpreted language\nDynamically typed with multiple dispatch and optional type annotations Dynamically typed with optional type annotations (Sorbet, RBS)\nBuilt-in parallelism via threads, coroutines (Tasks) Built-in parallelism via threads, fibers\nLisp-like (homoiconic, macro-based) metaprogramming Primarily runtime metaprogramming\nSingle implementation available (JuliaLang) Multiple implementations available (TruffleRuby, mruby, etc.)","category":"page"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"To transition from Ruby to Julia:","category":"page"},{"location":"comparisons/bioruby/","page":"BioRuby (Ruby)","title":"BioRuby (Ruby)","text":"Read the Julia manual for an in-depth look at its internals and features\nSee Running External Programs in the manual for running Ruby scripts or other programs from Julia","category":"page"},{"location":"getting_started/biojuliainstallation/#biojuliainstallation","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"","category":"section"},{"location":"getting_started/biojuliainstallation/#Standard-installation","page":"Installing BioJulia Packages","title":"Standard installation","text":"","category":"section"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"As with any Julia package, you can easily install any BioJulia package with the help of the official built-in package manager.  All you need to know is the name of the package of interest!","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"There are two standard methods to install a package:","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"note: Note\nThe Julia package manager, similarly to conda and others, organizes dependencies according to the \"environment\" they are in, meaning in which directory the packages are installed to. The default Julia session adds packages to a \"global\" environment, usually the .julia/environments/v1.x directory. When you are developing a package, you must activate its project-specific environment by calling activate MyProjectName (see Package development below) so that you can isolate your dependencies from the global environment and manage them independently. See Working with Environment for more details.","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"The package manager (Pkg) module","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"julia> using Pkg\n# Install the package\njulia> Pkg.add(\"<name of package here>\")\n# Use the installed package\njulia> using <name of package here>","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"note: Note\nOne excellent trick is that any Julia code with the julia> prompt included at the beginning of the line can be copy/pasted as is into the REPL! See the Julia REPL section for more details.","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"Pkg mode","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"# Enter ]\n]\n# @v1.x will show your current Julia version\n(@v1.9) pkg> add <name of package here>\n# Exit Pkg REPL mode via the Backspace key\njulia> using <name of package here>","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"note: Note\nJust like with the previous method, you can copy/paste code with the (@v1.x) pkg> prompt included and Julia will work correctly! You can even skip having to enter Pkg mode by just entering directly (@v1.x) pkg> add.... You do not need to manually change the version number indicated in the prompt if you have a different Julia version than that which is listed, it is all handled for you.","category":"page"},{"location":"getting_started/biojuliainstallation/#pkg-devel","page":"Installing BioJulia Packages","title":"Package development","text":"","category":"section"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"If you are interested in developing a new or existing BioJulia/Julia package, the package manager can also help you by first cloning the package repository to your development machine. Pkg will then load the required dependencies in a new dependency environment based on the package's Project.toml file. Thereafter, both the direct and indirect dependencies can be locked using a generated Manifest.toml if desired and a pull request can be submitted. ","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"There are two standard methods to set up Julia for developing a package:","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"The package manager (Pkg) module   ","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"julia> using Pkg\njulia> Pkg.develop(\"<name of package here>\")\njulia> using <name of package here>","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"Pkg mode","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"# Enter ]\n]\n# If the package is within a remote Git repository, write instead\n# `dev https://github.com/<name of account>/<package name>`\n(@v1.9) pkg> dev <name of package here>\n# Make sure you are within the same directory as the package folder\n(@v1.9) pkg> activate /path/to/package/folder/PackageName\n# The previous command activates the environment as directed by the\n# package's Project.toml file. This next command will then download\n# all of the dependencies specified in that file into your Julia environment.\n(@v1.9) pkg> instantiate\n# Exit REPL via the Backspace key\njulia> using <name of package here>","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"note: Note\nYou can skip straight to (@v1.9) pkg> activate ... if you have already installed the package locally, simply make sure to point Pkg to the right path as shown above.","category":"page"},{"location":"getting_started/biojuliainstallation/","page":"Installing BioJulia Packages","title":"Installing BioJulia Packages","text":"You can now change your source code and load it into the Julia session with using <name of package here>. To test your code, run (@v1.9) pkg> test to execute the package's test suite and ensure that everything works correctly. When you are done developing the package, enter (@v1.9) pkg> free to stop tracking the package. ","category":"page"},{"location":"comparisons/biojava/#biojava","page":"BioJava (Java)","title":"BioJava (Java)","text":"","category":"section"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"BioJava is a biological data processing library written in the Java programming language\nBioJava tooling is distributed via multiple classes within the same org.biojava package\nLaunched in 2002 with six major releases covering more than 11 Java releases","category":"page"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"A few similar applications between BioJulia and BioJava:","category":"page"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"Application BioJulia packages BioJava modules\nInput/Output FASTX, XAM, BigWig, etc. nbio.genome.io.fastq, nbio.ontology.obo, etc.\nSequence alignment BioSequences, BioAlignments nbio.sequence, nbio.alignment\nMacromolecular structures BioStructures nbio.structure","category":"page"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"A few package/ecosystem equivalents between Julia and Java:","category":"page"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"Application Julia Java\nData manipulation/analysis DataFrames, CSV, Query Tablesaw\nPlotting/visualization Plots, Makie, TidierPlots JFreeChart, Jzy3d\nStatistical analysis Statistics, HypothesisTests Statistics (Apache Commons), NM Dev\nMachine learning Flux, SciML,  MLJ Java-ML, Neuroph\nNumerical mathematics LinearAlgebra NM Dev\nNotebook/report generator IJulia, Pluto IJava\nWeb applications Genie, Franklin Grails, Javalin","category":"page"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"A few notable differences between Julia and Java:","category":"page"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"Julia Java\nHigh-level, general-purpose compiled language High-level, object-oriented, two-step (compiled and interpreted) language\nExpression-based (statements yield a value) Statement-based (statements don't always yield a value)\nDynamically typed with multiple dispatch and optional type annotations Statically typed with required type declarations\nBuilt-in parallelism via threads, coroutines (Tasks) Built-in parallelism via threads, streams, fibers (Project Loom)\nLisp-like (homoiconic, macro-based) metaprogramming Reflection-based runtime metaprogramming\nIncluded default package manager No default package manager (dependency/build management tools include Maven, Gradle, etc.)\nSingle implementation available (JuliaLang) Multiple implementations available (OpenJDK, GraalVM, etc.)","category":"page"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"To transition from Java to Julia:","category":"page"},{"location":"comparisons/biojava/","page":"BioJava (Java)","title":"BioJava (Java)","text":"Use JavaCall.jl to seamlessly integrate Java code into your Julia project\nSee Running External Programs in the Julia manual for running Java scripts or other programs from Julia","category":"page"},{"location":"comparisons/scikitbio/#scikitbio","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"","category":"section"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"scikit-bio represents a Python3 library providing data structures, algorithms, and additional bioinformatics resources\nUnlike with BioJulia, scikit-bio tools are installed together as modules into a single skbio package \nLaunched in 2014 based on a BSD-relicensing of PyCogent and QIIME code and is currently in beta/maintenance mode","category":"page"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"A few similar applications between BioJulia and scikit-bio:","category":"page"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"Application BioJulia packages scikit-bio modules\nSequence alignment BioSequences, BioAlignments skbio.sequence, skbio.alignment\nInput/Output FASTX, XAM, BigWig,... skbio.io\nData structures IntervalTrees skbio.tree","category":"page"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"A few package/ecosystem equivalents between Julia and Python3:","category":"page"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"Application Julia Python3\nData manipulation/analysis DataFrames, CSV, Query pandas, Blaze\nPlotting/visualization Plots, Gadfly, Makie, TidierPlots matplotlib, seaborn, bokeh, plotnine, VisPy\nStatistical analysis Statistics, HypothesisTests, GLM SciPy, statsmodels\nMachine learning Flux, SciML,  MLJ, Zygote PyTorch, TensorFlow, scikit-learn, JAX\nNumerical mathematics LinearAlgebra, Symbolics NumPy, SciPy, SymPy\nNotebook/report generator IJulia, Pluto, Weave IPython, Jupyter Book\nWeb applications Genie, Franklin Django, Flask, Pelican, Dash","category":"page"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"A few notable differences between Julia and Python3:","category":"page"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"Julia Python3\nHigh-level, general-purpose compiled language High-level, general-purpose interpreted language\nExpression-based (statements yield a value) Statement-based (statements don't always yield a value)\nDynamically typed with multiple dispatch and optional type annotations Dynamically typed with optional type annotations\nBuilt-in parallelism via threads, coroutines (Tasks) Limited (GIL) built-in parallelism via threads, async/await\nLisp-like (homoiconic, macro-based) metaprogramming Reflection-based runtime metaprogramming\nIncluded default package manager No default package manager (poetry, conda, and other alternatives available)\nSingle implementation available (JuliaLang) Multiple implementations available (PyPy, Numba, etc.)\nArrays are column-major (columns are contiguous in memory) (Numpy) arrays are row-major by default (rows are contiguous in memory)","category":"page"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"To transition from Python3 to Julia:","category":"page"},{"location":"comparisons/scikitbio/","page":"scikit-bio (Python3)","title":"scikit-bio (Python3)","text":"See Noteworthy differences from Python in the Julia manual for a more in-depth comparison\nUse PythonCall.jl/CondaPkg.jl to seamlessly integrate Python3 code into your Julia project\nUse juliacall to seamlessly integrate Julia code into your Python3 project","category":"page"},{"location":"comparisons/biopython/#biopython","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"","category":"section"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"Biopython represents an ecosystem of related biology tools written in the Python3 programming language\nUnlike with BioJulia, Biopython tools are installed together as modules into a single biopython package \nLaunched over two decades ago with major releases covering the Python2/3 transition\nCapabilities cover a number of molecular biology applications including sequence alignment, population genetics, and machine learning","category":"page"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"A few similar applications between BioJulia and Biopython:","category":"page"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"Application BioJulia packages Biopython objects/modules\nSequence annotation GenomicFeatures, GenomicAnnotations Seq, SeqRecord\nInput/Output FASTX, XAM, BigWig, etc. Bio.SeqIO, Bio.AlignIO\nSequence alignment BioSequences, BioAlignments Bio.Align\nPopulation genetics PopGen Bio.PopGen","category":"page"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"A few package/ecosystem equivalents between Julia and Python3:","category":"page"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"Application Julia Python3\nData manipulation/analysis DataFrames, CSV, Query pandas, Blaze\nPlotting/visualization Plots, Gadfly, Makie, TidierPlots matplotlib, seaborn, bokeh, plotnine, VisPy\nStatistical analysis Statistics, HypothesisTests, GLM SciPy, statsmodels\nMachine learning Flux, SciML,  MLJ, Zygote PyTorch, TensorFlow, scikit-learn, JAX\nNumerical mathematics LinearAlgebra, Symbolics NumPy, SciPy, SymPy\nNotebook/report generator IJulia, Pluto, Weave IPython, Jupyter Book\nWeb applications Genie, Franklin Django, Flask, Pelican, Dash","category":"page"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"A few notable differences between Julia and Python3:","category":"page"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"Julia Python3\nHigh-level, general-purpose compiled language High-level, general-purpose interpreted language\nExpression-based (statements yield a value) Statement-based (statements don't always yield a value)\nDynamically typed with multiple dispatch and optional type annotations Dynamically typed with optional type annotations\nBuilt-in parallelism via threads, coroutines (Tasks) Limited (GIL) built-in parallelism via threads, async/await\nLisp-like (homoiconic, macro-based) metaprogramming Reflection-based runtime metaprogramming\nIncluded default package manager No default package manager (poetry, conda, and other alternatives available)\nSingle implementation available (JuliaLang) Multiple implementations available (PyPy, Numba, etc.)\nArrays are column-major (columns are contiguous in memory) (Numpy) arrays are row-major by default (rows are contiguous in memory)","category":"page"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"To transition from Python3 to Julia:","category":"page"},{"location":"comparisons/biopython/","page":"Biopython (Python3)","title":"Biopython (Python3)","text":"See Noteworthy differences from Python in the Julia manual for a more in-depth comparison\nUse PythonCall.jl/CondaPkg.jl to seamlessly integrate Python3 code into your Julia project\nUse juliacall to seamlessly integrate Julia code into your Python3 project","category":"page"},{"location":"comparisons/bioperl/#bioperl","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"","category":"section"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"BioPerl represents an ecosystem of related molecular biology modules written in the Perl5 programming language\nSupported by the Open Bioinformatics Foundation and includes additional utilities and interfaces for common bioinformatics applications\nLaunched in 2002 and has contributed to major scientific achievements including the Human Genome Project","category":"page"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"A few similar applications between BioJulia and BioPerl:","category":"page"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"Application BioJulia packages BioPerl modules/objects\nInput/Output FASTX, XAM, BigWig, etc. SeqIO\nSequence alignment BioSequences, BioAlignments AlignIO, SimpleAlign\nData structures Kmers, IntervalTrees Bio::Kmer, Bio::Tree\nPopulation Genetics PopGen PopGen","category":"page"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"A few package/ecosystem equivalents between Julia and Perl5:","category":"page"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"Application Julia Perl5\nData manipulation/analysis DataFrames, CSV, Query PDL, Text-CSV\nPlotting/visualization Plots, Gadfly, Makie, TidierPlots GDGraph, Chart-GGPlot\nStatistical analysis Statistics, HypothesisTests, GLM Statistics-Descriptive, PDL-Stats\nNumerical mathematics LinearAlgebra, Symbolics PDL-LinearAlgebra, Math-Symbolic\nNotebook/report generator IJulia, Pluto Devel-IPerl\nWeb applications Genie, Franklin Catalyst, Mojolicious","category":"page"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"A few notable differences between Julia and Perl5:","category":"page"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"Julia Perl5\nHigh-level, general-purpose compiled language High-level, general-purpose interpreted language\nDynamically typed with multiple dispatch and optional type annotations Dynamically typed without type annotations support\nBuilt-in parallelism via threads, coroutines (Tasks) Parallelism via threads, external modules (Coro, Parallel, etc.)\nLisp-like (homoiconic, macro-based) metaprogramming Primarily runtime metaprogramming\nSingle language implementation (JuliaLang) Family of related languages/implementations (Perl5, Perl6/Raku, ActivePerl, etc.)","category":"page"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"To transition from Perl5 to Julia:","category":"page"},{"location":"comparisons/bioperl/","page":"BioPerl (Perl5)","title":"BioPerl (Perl5)","text":"Read the Julia manual for an in-depth look at its internals and features\nSee Running External Programs in the manual for running Perl scripts or other programs from Julia","category":"page"},{"location":"getting_started/toolsinstallation/#toolsinstallation","page":"Installing Development Tools","title":"Installing Development Tools","text":"","category":"section"},{"location":"getting_started/toolsinstallation/#julia-repl","page":"Installing Development Tools","title":"Julia REPL","text":"","category":"section"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"A REPL, or read-eval-print loop, represents a language \"shell\" or program that allows the user to communicate with the programming language interactively. This allows for rapid prototyping and exploring the language more deeply with immediate feedback.","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"The Julia REPL is included by default in every Julia installation and boasts a number of features found in many integrated development environments (IDEs). It should appear the moment you enter julia into your terminal:","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.2 (2023-07-05)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Here is a quick rundown of features most Julia users should know to make the most of the REPL:","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"There are 5 Julia REPL modes that serve separate purposes:\nThe Julian (default) mode wherein one can write, load, and test out code\nHelp mode for printing documentation for functions, keywords, etc.\nPkg mode for working with the included package manager and manipulating dependencies/packages\nShell mode to execute system commands (run a terminal from Julia which itself is running from a terminal!)\nSearch modes (forward, reverse) to look through your history of inputs","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Prompt Key binding\njulia> None (default mode)\nhelp?> ? or ?? (extended help)\n(@v1.x) pkg> ]\nshell> ;\n(reverse-i-search): ^R\n(forward-i-search): ^S","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"If you have a code editor installed on your machine, you can go back and forth between the Julia session and the editor by entering julia> edit(\"<name of file>\"). You can jump right back into the Julia session once you're finished.\nYou can get a list of matches to a partially written word by entering the TAB key, which also serves to render a Unicode character in the REPL (full list available in the Unicode Input section of the Julia manual):\njulia> pri[TAB]\nprimitive type  print           println         printstyled\njulia> \\pi[TAB] # renders Ï€\nYou can run a standalone script by entering include(\"<name of script>\") in Julian mode. For greater control, the equivalent of Python3's if __name__ == __main__ condition would be if abspath(<name of program file>) == @__FILE__","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"warning: Warning\nOne common gotcha with the Julia REPL is that certain code changes cannot be performed without restarting your session, such as redefining structs (see the example below). You can mitigate this by adding the Revise package, although restarting the session is the simplest option. `  julia> struct Point\n          x::Int\n          y::Int\n         end\n\n  julia> struct Point\n          x::Int\n          z::Int\n        end\n  ERROR: invalid redefinition of constant Point\n  Stacktrace:\n  [1] top-level scope\n  @ REPL[2]:1","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Consult the The Julia REPL section in the Julia manual for more details.","category":"page"},{"location":"getting_started/toolsinstallation/#Visual-Studio-Code-extension","page":"Installing Development Tools","title":"Visual Studio Code extension","text":"","category":"section"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"The Julia organization officially supports the julia-vscode extension which, together with VS Code, provides a complete solution for developing in Julia similar to an IDE. This boasts a number of advantages compared to a pure REPL-driven solution:","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Built-in syntax highlighting and code completion\nGUI interaction for managing options and commands\nAdvanced profiling/debugging features\nAdditional extensions support","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Follow the installation instructions from the official website. After opening VS Code, click on the Extension icon in the side Activity Bar and search for \"Julia\". The official Julia extension should be the first extension available. You can also install Julia within the Quick Open input panel by pressing Ctrl + P and entering ext install julialang.language-julia.","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"(Image: Julia VS Code Extension)","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Install the extension and restart VS Code. We also recommend installing some additional extensions that will further improve the development experience:","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Even Better TOML (ext install tamasfe.even-better-toml) for working with the package TOML files (Project.toml, Manifest.toml, Artifacts.toml,...)\nGitLens (ext install eamodio.gitlens) for enhancing Git workflows","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"You can experiment with Julia extension features in the Quick Open panel by writing Julia and consulting the available options. To learn more, visit the Julia in Visual Studio Code page or the Julia extension's official website.","category":"page"},{"location":"getting_started/toolsinstallation/#Alternative-Editor/IDE-extensions","page":"Installing Development Tools","title":"Alternative Editor/IDE extensions","text":"","category":"section"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Although julia-vscode is the only officially supported extension, community extensions are available for a range of code editors/IDEs:","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"julia-emacs that integrates a new major mode for developing in Julia\njulia-vim to enable Julia support for Vim/Neovim\njulia-sublime to enable Julia support for Sublime","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Certain editors/IDEs, such as GodBolt and Replit, already support Julia without extensions. Finally, many editors, like micro, natively include support for basic features such as code highlighting or simple autocomplete.","category":"page"},{"location":"getting_started/toolsinstallation/#Notebooks","page":"Installing Development Tools","title":"Notebooks","text":"","category":"section"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"A reactive notebook is an interactive environment that combines elements of a code editor and a REPL into one solution. One writes code in executable blocks of \"cells\" that can be mixed with text and other assets to create a reproducible document that is shareable and easily manipulable. Notebooks are especially useful for scientific exploration since code can be rapidly prototyped in an isolated environment that can be both visualized and documented in the same file.","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"There are two standard methods for working with Julia in notebooks:","category":"page"},{"location":"getting_started/toolsinstallation/#IJulia-(Julia-kernel-for-Jupyter)","page":"Installing Development Tools","title":"IJulia (Julia kernel for Jupyter)","text":"","category":"section"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"The Julia organization officially supports the IJulia kernel, or backend, for Jupyter notebooks, which is the most popular web-based notebook solution.","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"To install IJulia/Jupyter and run the notebook server:","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"note: Note\nInstead of loading Pkg, one can simply activate pkg mode with the ] key and enter (@v1.9) pkg> add <package name here>","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Install Julia via any method mentioned in the Installing Julia section\nOpen the Julia REPL by entering julia into your terminal\nAdd the IJulia package via the built-in package manager: julia> using Pkg;Pkg.add(\"IJulia\")\nLoad IJulia and launch the notebook server: julia> using IJulia; notebook() (run notebook(detached=true) if you wish that the notebook, and notebook(dir=\"/some/path\") if you wish to open a notebook in a ) server sruns in the background even if the Julia session is closed)\nEnter y to install Jupyter via Conda if you have not done so already on your machine","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"The notebook dashboard should open within your web browser. If you already have jupyter installed (Installing Jupyter), you can enter n when prompted by the Julia REPL and instead run jupyter notebook from the terminal. Visit the Running IJulia section in the official IJulia docs for more information.","category":"page"},{"location":"getting_started/toolsinstallation/#Pluto-notebooks","page":"Installing Development Tools","title":"Pluto notebooks","text":"","category":"section"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Pluto.jl is an alternative notebook solution built with Julia in mind. It integrates well with the language and boasts a number of features that are not available or are difficult to achieve with Jupyter:","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Works with Julia's built-in package manager for native reproducibility\nLive docs feature (essentially Julia's help mode available within the notebook)\nWorks with normal Julia (.jl) files as opposed to .ipynb files\nExtendable via packages like PlutoUI and PlutoPDF","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"To install and run the Pluto server:","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"Install Julia via any method mentioned in the Installing Julia section\nOpen the Julia REPL by entering julia into your terminal\nAdd the Pluto package via the built-in package manager: julia> using Pkg;Pkg.add(\"Pluto\")\nLoad Pluto and launch the notebook server: julia> using Pluto; Pluto.run()\nCopy/paste the given URL (http://localhost:...) into your web browser","category":"page"},{"location":"getting_started/toolsinstallation/","page":"Installing Development Tools","title":"Installing Development Tools","text":"A number of featured notebooks are available online that include basic tutorials and powerful demonstrations achieved with Pluto.","category":"page"},{"location":"overview/#overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Overview-of-the-BioJulia-Ecosystem","page":"Overview","title":"Overview of the BioJulia Ecosystem","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"BioJulia is an ","category":"page"},{"location":"overview/#","page":"Overview","title":"","text":"","category":"section"},{"location":"overview/#Common-Julia-packages","page":"Overview","title":"Common Julia packages","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Below are a few examples of common Julia packages that are ","category":"page"},{"location":"#BioJulia:-Fast,-open,-easy-software-for-biology","page":"BioJulia: Fast, open, easy software for biology","title":"BioJulia: Fast, open, easy software for biology","text":"","category":"section"},{"location":"","page":"BioJulia: Fast, open, easy software for biology","title":"BioJulia: Fast, open, easy software for biology","text":"Note: This landing site is under extensive development and will receive frequent updates. It is not in a ready state, and is published under GitHub Pages only for testing purposes. ","category":"page"},{"location":"","page":"BioJulia: Fast, open, easy software for biology","title":"BioJulia: Fast, open, easy software for biology","text":"BioJulia is a passionate, community-led organization providing biology-related packages written in the Julia programming language. The organization offers a comprehensive, fully open-source ecosystem of both libraries that serve as essential building blocks for other packages as well as interactive tools for everyday tasks and workflows. ","category":"page"},{"location":"","page":"BioJulia: Fast, open, easy software for biology","title":"BioJulia: Fast, open, easy software for biology","text":"Biologists and other scientists are fully empowered by Julia to easily tackle domain-specific challenges, taking advantage of features including:","category":"page"},{"location":"","page":"BioJulia: Fast, open, easy software for biology","title":"BioJulia: Fast, open, easy software for biology","text":"Fully reproducible environments thanks to Julia's built-in package manager\nCompetitive performance that rivals that of lower-level, more complex languages such as C and Fortran\nUnicode-based math symbol support, transparent BLAS integration, and additional features for performing complex numerical operations   \nA batteries-included read-eval-print loop (REPL) for interactive data exploration and prototyping\nSeamless interoperability (JLLs, Cmd,...) with other languages via multiple foreign function interfaces","category":"page"},{"location":"#Where-to-Start?","page":"BioJulia: Fast, open, easy software for biology","title":"Where to Start?","text":"","category":"section"},{"location":"","page":"BioJulia: Fast, open, easy software for biology","title":"BioJulia: Fast, open, easy software for biology","text":"Take a look at all BioJulia code via the official GitHub   page\nBegin contributing ideas and features following the core   guidelines\nDeep dive into the ecosystem over at the Overview\nStart learning right away using the Getting Started tutorials\nSee some awesome examples in the BioJulia Showcase\nCome chat with us over in the Slack #biology   channel and on forums","category":"page"},{"location":"","page":"BioJulia: Fast, open, easy software for biology","title":"BioJulia: Fast, open, easy software for biology","text":"Use the top navigation bar to search for provided packages within one's field of interest.","category":"page"},{"location":"getting_started/casescenarios/#casescenarios","page":"Case Scenarios","title":"Case Scenarios","text":"","category":"section"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"note: Note\nThese scenarios are inspired by stories from fellow members of the BioJulia/Julia community!","category":"page"},{"location":"getting_started/casescenarios/#Industry","page":"Case Scenarios","title":"Industry","text":"","category":"section"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"tip: Tip\nVisit JuliaHub for real-world case studies of Julia in multiple industries!","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"A biotechnology-oriented collaborative research organization has ordered their IT department to organize the first in-house software development division. Researchers are divided into teams that each serve one client at a time, though they all share the same laboratory and equipment. The need for an in-house programming division has arisen based on feedback from these teams facing many similar problems with the current workplace setup:","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"Researchers may not be digitally literate, thus they require more accessible user interfaces\nLessening the number of tools they are required to learn would ideally reduce complexity and onboarding time\nSome workflows can be repetitive and could take advantage of some automation to reduce overall time","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"It is thus decided that a researcher-facing platform should be created that will host a suite of simple, web-based software tools. These can include tools usable by any researcher or by only one or several teams depending on their needs. The new division is given the following objectives:","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"Collaborate with researchers and understand their software requirements\nUse modern languages/frameworks to avoid technical headaches and allow for faster onboarding\nEnsure access to both general and scientific libraries when needed for a specific tool","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"Upon reviewing these objectives, the division begins discussing which tech stacks they should use. With a mix of veteran and junior talent, as well as a desire to allow for fast time-to-deployment and performance, it is agreed that a modern, higher-level programming language would be ideal. One of the collaborating researchers suggests they look into Julia, which has been the scripting language of choice amongst some of the teams for automating several workflows, and the division decides to push ahead with a trial.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The platform and first two tools for the collaborating research team are prototyped. The stack is built upon the Genie web framework, which, crucially, enables authorization/authentication support on a team-by-team basis and HTML/CSS/JS interoperability. The entire platform is designed as a reactive app that can be deployed anywhere and is almost entirely written in Julia for both the frontend and backend. Further Genie ecosystem packages and plugins spur potential ideas like taking advantage of the included no-code UI builder for producing team analytics dashboards.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The first tool conceived allows teams to upload, download, and manage files or datasets within the company's shared drive from the web. It is designed to handle data management on its own without the researchers needing to remember specific drive locations or other details, their only responsibility being categorization (data pulled from which instrument, for which project, etc.). The tool is able to manage the data by working with the company's S3 and S3 Glacier storage instances via the AWS package. A user-facing feature is also included that generates an Artifacts.toml file, allowing researchers to use Julia's Artifact system to declaratively point to select data and download them when required. For the more tech savvy user, an input feature is set up to allow for DuckDB database queries for large datasets. An official Julia package is provided for this DBMS, however, a JLL is also available for more direct use of the DuckDB program. The ability to bundle external programs written in other languages and treat them as first-class Julia packages also means that porting over common scientific tools greatly simplifies dependency management for both developers and researchers. Seamless interoperability also extends to the ability to interact with codes from other languages such as Python with PythonCall/CondaPkg and R with RCall.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The second tool conceived is designed specifically for a collaborating researcher who needs to determine total cell count following each cell passage. The researcher uploads a photo of a stained cell culture sample, along with inputs such as total medium volume and dilution factor. The developers make use of the ImageSegmentation package for differentiating live and dead cells through the use of the watershed algorithm. A side-by-side view is generated with the original and segmented image, as well as the total number of markers indicating the amount of live cells.o Although only a prototype, the developers believe it would be more than possible to employ basic machine learning using the SciML ecosystem.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The trial period with the collaborating research team proves to be a success, and the company decides to fully commit to this Julia platform. Novel ideas are tossed about internally over which tools can further improve workflows, such as replacing their electronic lab notebook systems with Pluto and embedding a quick statistics calculator for linear regression modelling with GLM and Makie. It is even discussed how this platform may allow the company to eventually commercialize these tools for other contract research organizations that face the same challenges.","category":"page"},{"location":"getting_started/casescenarios/#Research","page":"Case Scenarios","title":"Research","text":"","category":"section"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"tip: Tip\nVisit The Journal of Open Source Software and JuliaCon Proceedings to explore several research packages written in Julia!","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"A freshly minted researcher begins the morning with a new directive from the principal investigator. Their lab specializes in translational cancer immunotherapy, and as of late have been exploring a potential avenue for T-cell activation in patients with a rare type of lymphoma. It is hoped that strengthening the expression of specific peptides involved in cellular adaptive immune response can lead to more effective treatment. One patient's blood has been sampled and delivered to the lab, with the goal of extacting and combing through the resulting expression data from various antigen-presenting cells (APCs) to identify abnormal peptide expression levels.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The researcher understands that the exploratory nature of this project will require an interactive environment from which results can be rapidly generated and saved/discarded. Previously, a number of challenges would get in the way of this workflow:","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"Working with interactive languages had proven to be a hassle due to issues like competing build systems and environments\nThe REPL experience was often lacking due to missing features or lack of integrations with other tools like a package manager\nExisting digital notebook solutions suffer from lackluster performance and difficulties with deployment and versioning\nWriting high-performance software would require lower-level languages like C or Fortran, which would prove difficult for scientists without a computer science background","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"They remember having heard of Julia from colleagues, and decide to give it a go. Installation proved to be very simple with the juliaup tool, and they proceed to read up on the basics from the Julia manual. The first step, upon loading the Julia REPL, is to add the DrWatson package to better track the project. With DrWatson and the built-in package manager, the researcher can geneate reproducible code for simulations, plotting, and data preparation.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"At the same time, the researcher isolates the APCs via a microfluidic cell-sorting device. The patient's cells are encapsulated into individual droplets from which single-cell profiling can occur via Droplet-Sequencing (Drop-seq). The resulting data is stored in .h5 files on the lab's shared drive. The researcher generates an Artifacts.toml file that utilizes Julia's built-in Artifact system to point to these files in a persistent and reproducible manner. The researcher makes quick work of loading the data into Julia with the HDF5 package, and applies a number of steps with DataFrames, TidierData, and Chain to transform, normalize, and filter the data. Finally, principle component analysis (PCA) with SingleCellProjections is conducted, visualized with the help of the Makie plotting package.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The whole project is saved by DrWatson and shared with the principal investigator for further discussion. PCA analysis leads them to focus on a narrow subset of APCs with elevated peptide expression levels which will be further investigated in subsequent studies. The researcher prepares a more digestible format of the results as a Pluto notebook to share with colleagues the more pertinent observations, and finally a more formal research report with Julia code included is written with Weave. The lab is impressed with what was achieved with Julia, with many remarking how effortless it seemed to achieve great performance with such a high-level language.","category":"page"},{"location":"getting_started/casescenarios/#Education","page":"Case Scenarios","title":"Education","text":"","category":"section"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"A new teacher was recently hired to teach a biostatistics course for first-year students at the University of Concordia. This will be a new offering at the university, thus they have been given free reign to design their own course plan. They are most interested in engaging students with a series of practical components, including hands-on demonstrations and involved coding projects. They look for inspiration from similar courses, and finds that many are aiming to develop a strong foundation in statistical programming for handling data analysis, hypothesis testing, and other tasks.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"A number of these courses teach R or Python3, which have been entrenched in statistics for a number of years. They also appear to be popular with new programmers due to being high-level and easy to learn. However, the new teacher encounters a number of issues that raise concern:","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"Performance would become an issue with larger datasets or visual plots, with the language taking too long to generate output and thus wasting valuable class time\nBoth languages come with a number of design decisions that may confuse beginners, such as how they handle missing values and introduce complex object-oriented systems\nSetting up reproducible environments with all the necessary bits (dependencies, data) in either language is challenging, with a number of limitations and choices presented including package manager, language implementation, etc.\nThere is a desire to avoid the \"two-language problem\" wherein parts of either language are written in another and thus introduce unneeded complexity","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"A fellow professor recommends they look into Julia, which has already found success within certain departments. The teacher consults the Julia manual and toys with the language itself and several statistical packages. They discover that Julia possesses a number of features relevant for both teaching and engaging with the course, including the built-in package manager and rich REPL experience, and decides to proceed forward with it.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The first objective is to create a presentation format with good aesthetics that can also demonstrate code samples. They discover how to set up interactive notebooks with Pluto that will be hosted in a central repository or online via a website or with solutions like Binder. This has a number of advantages compared to PowerPoint or Markdown presentations:","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"Easily run and experiment with code cells within a reproducible environment\nDependency management automatically handled via the built-in package manager\nShare the code and lessons with students either as notebooks or as exported PDF/HTML pages","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"To bundle the datasets with the notebooks, they take advantage of Julia's Artifact system for handling and retrieving data from almost anywhere on the Internet.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"With the course infrastructure set, attention is now put towards creating the actual course material. They can cover a number of biostatistics topics using powerful, well-established Julia packages:","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"Plots or Makie for data visualization\nDataFrames, CSV, and Tidier for data handling\n[Statistics] and [StatsBase] for general statistical functionality (scalar statistics, estimation, ...)\nDistributions for probability and sampling\nHypothesisTests for parametric (ANOVA, chi-squared, ...) and non-parametric testing\nGLM for generalized linear modelling\nFlux or MLJ for basic machine learning","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The course agenda is almost complete. However, just before the start of the semester, a new lesson on Tukey's honest significance test is added. There is no package written in Julia yet for this test, and there is little time left to develop the code on their own. Luckily, Julia posseses incredible interoperability with both Python3 and R, and they discover how to both call and bundle Scipy's stats.tukey_hsd function via PythonCall and CondaPkg.","category":"page"},{"location":"getting_started/casescenarios/","page":"Case Scenarios","title":"Case Scenarios","text":"The teacher goes on to smoothly deliver the newly introduced course, empowered by Julia to deliver an engaging experience for teaching students both the fundamentals of biostatistics and of quality programming.","category":"page"},{"location":"getting_started/juliainstallation/#juliainstallation","page":"Installing Julia","title":"Installing Julia","text":"","category":"section"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"There are a number of official methods available to install Julia, each with their own purposes and advantages:","category":"page"},{"location":"getting_started/juliainstallation/#juliaup-(recommended)","page":"Installing Julia","title":"juliaup (recommended)","text":"","category":"section"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"juliaup is a Julia manager/version multiplexer tool designed to handle your Julia installation from the command-line. It is the easiest and most convenient installation option, and is available on almost all platforms that support Julia.","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"If you are running Linux or Mac, enter the following command in your terminal:","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"If you are running Windows, enter the following:","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"winget install julia -s msstore","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"If you have the Rust programming language installed on your machine, you can generate the juliaup executable via the Cargo package manager:","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"warning: Warning\nThis is not recommended for the most users, and should be avoided unless you cannot download the official juliaup executable.","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"cargo install juliaup","category":"page"},{"location":"getting_started/juliainstallation/#Docker/Podman","page":"Installing Julia","title":"Docker/Podman","text":"","category":"section"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"An official Docker image is available, allowing you to build containers with Julia already installed. This can be a preferred method of installation if you wish to run Ju lia in a sandboxed, ephemeral (temporary) instance or are looking to include Julia in a containerized application.","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"You must first download the image via the Docker or Podman command-line tool:","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"note: Note\nIf you are using Podman, you can replace the keyword docker with podman in any of the following commands!","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"docker pull julia:latest","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"You can specify which version of the image you wish to install via tags, such as latest, rc, 1.6, etc.","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"To create a container instance, run the following command:","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"note: Note\nIf you had skipped the previous test, then Docker/Podman will automatically begin installing the container image for you here!","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"docker run -it --rm --network host julia:latest","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"The above command creates an interactive container that will be deleted the moment you exit via the --rm option and that will share your machine's network namespace via the --network host option (allow for automatic port bindings). You may remove either option to disable these behaviours.","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"The image itself can serve as a base for your custom container built from a Dockerfile/Containerfile:","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"FROM julia:latest\n# ...","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"If you wish to use a different image as the basis of your container, yet still require Julia, you can use any of the other installation methods listed in this section in your Dockerfile/Containerfile. A few examples with juliaup:","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"# First option: Install juliaup via curl\nFROM ubuntu:latest\n\nRUN apt update && \\\n    apt install -y curl && \\\n    curl -fsSL https://install.julialang.org | sh -s -- -y # install juliaup non-interactively\n\nRUN juliaup add release","category":"page"},{"location":"getting_started/juliainstallation/#Manual-download","page":"Installing Julia","title":"Manual download","text":"","category":"section"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"You can also install the Julia executable directly from the Julia website's Manual Download section. You must make sure to install the correct Julia executable based on your machine's:","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"native instruction set (x86_64, i686, ARM, Apple Silicon, PowerPC)\noperating system type (Windows, MacOS, Linux (Glibc), Linux (Musl), FreeBSD)\nbit compute type (32-bit, 64-bit)","category":"page"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"Make sure to follow the platform specific instructions for your machine in order to ensure the best experience.","category":"page"},{"location":"getting_started/juliainstallation/#Build-from-source","page":"Installing Julia","title":"Build from source","text":"","category":"section"},{"location":"getting_started/juliainstallation/","page":"Installing Julia","title":"Installing Julia","text":"You may build Julia from the source code that is openly available in the Julia GitHub repository. Please consult the Building Julia (Detailed) section of the Julia manual for more details.","category":"page"}]
}
